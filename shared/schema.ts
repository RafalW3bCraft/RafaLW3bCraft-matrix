import {
  pgTable,
  text,
  varchar,
  timestamp,
  jsonb,
  index,
  serial,
  integer,
  boolean,
} from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Session storage table - required for Replit Auth
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)],
);

// User storage table - enhanced for RBAC and OAuth
export const users = pgTable("users", {
  id: varchar("id").primaryKey().notNull(),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  username: varchar("username").unique(),
  bio: text("bio"),
  profileImageUrl: varchar("profile_image_url"),
  role: varchar("role").default("user"), // admin, user, visitor
  provider: varchar("provider"), // google, github, replit
  providerId: varchar("provider_id"),
  isActive: boolean("is_active").default(true),
  lastLogin: timestamp("last_login"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Blog posts table - enhanced with user authorship
export const blogPosts = pgTable("blog_posts", {
  id: serial("id").primaryKey(),
  title: varchar("title").notNull(),
  slug: varchar("slug").unique().notNull(),
  content: text("content").notNull(),
  excerpt: text("excerpt"),
  authorId: varchar("author_id").references(() => users.id),
  published: boolean("published").default(false),
  approved: boolean("approved").default(false), // admin approval
  isDraft: boolean("is_draft").default(true),
  isAutoGenerated: boolean("is_auto_generated").default(false), // AI-generated from GitHub
  tags: text("tags").array().default([]),
  views: integer("views").default(0),
  githubRepo: varchar("github_repo"), // source repo for auto-generated posts
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Contact messages table
export const contactMessages = pgTable("contact_messages", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull(),
  email: varchar("email").notNull(),
  subject: varchar("subject").notNull(),
  message: text("message").notNull(),
  createdAt: timestamp("created_at").defaultNow(),
});

// Audio play logs to prevent re-triggering falcon sounds
export const audioPlayLogs = pgTable("audio_play_logs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  audioType: varchar("audio_type").notNull(), // falcon-rising, falcon-cry, etc
  playedAt: timestamp("played_at").defaultNow(),
  sessionId: varchar("session_id"),
});

// System audit logs for Falcon's Mandate security monitoring
export const auditLogs = pgTable("audit_logs", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id),
  action: varchar("action").notNull(), // login, admin_access, blog_edit, etc
  resource: varchar("resource"), // blog_post, user, system
  details: jsonb("details"), // action metadata
  ipAddress: varchar("ip_address"),
  userAgent: varchar("user_agent"),
  severity: varchar("severity").default("info"), // info, warning, critical
  createdAt: timestamp("created_at").defaultNow(),
});

// Failed login attempts for security monitoring
export const failedLoginAttempts = pgTable("failed_login_attempts", {
  id: serial("id").primaryKey(),
  email: varchar("email"),
  ipAddress: varchar("ip_address").notNull(),
  userAgent: varchar("user_agent"),
  attemptedAt: timestamp("attempted_at").defaultNow(),
  provider: varchar("provider"), // google, github
});

// System health monitoring
export const systemHealth = pgTable("system_health", {
  id: serial("id").primaryKey(),
  metricType: varchar("metric_type").notNull(), // performance, security, uptime
  metricName: varchar("metric_name").notNull(),
  value: jsonb("value"),
  status: varchar("status").default("healthy"), // healthy, warning, critical
  checkedAt: timestamp("checked_at").defaultNow(),
});

// Analytics table for tracking page views and stats
export const analytics = pgTable("analytics", {
  id: serial("id").primaryKey(),
  path: varchar("path").notNull(),
  userAgent: text("user_agent"),
  ipAddress: varchar("ip_address"),
  timestamp: timestamp("timestamp").defaultNow(),
});

// GitHub projects table (optional - for caching GitHub data)
export const githubProjects = pgTable("github_projects", {
  id: serial("id").primaryKey(),
  name: varchar("name").notNull().unique(),
  description: text("description"),
  language: varchar("language"),
  stars: integer("stars").default(0),
  url: varchar("url").notNull(),
  lastUpdated: timestamp("last_updated").defaultNow(),
});

// Real-time messaging system
export const messages = pgTable("messages", {
  id: serial("id").primaryKey(),
  senderId: varchar("sender_id").references(() => users.id).notNull(),
  recipientId: varchar("recipient_id").references(() => users.id), // null for admin messages
  content: text("content").notNull(),
  originalContent: text("original_content"), // before AI moderation/rewriting
  isModerated: boolean("is_moderated").default(false),
  moderationAction: varchar("moderation_action"), // filtered, rewritten, flagged
  roomId: varchar("room_id"), // for group chats
  messageType: varchar("message_type").default("text"), // text, image, file
  isRead: boolean("is_read").default(false),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Blog comments system with moderation
export const comments = pgTable("comments", {
  id: serial("id").primaryKey(),
  blogPostId: integer("blog_post_id").references(() => blogPosts.id).notNull(),
  authorId: varchar("author_id").references(() => users.id).notNull(),
  content: text("content").notNull(),
  originalContent: text("original_content"), // before AI moderation
  isModerated: boolean("is_moderated").default(false),
  moderationAction: varchar("moderation_action"),
  approved: boolean("approved").default(false),
  parentCommentId: integer("parent_comment_id"), // self-reference will be added later
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

// Moderation logs and AI analysis
export const moderationLogs = pgTable("moderation_logs", {
  id: serial("id").primaryKey(),
  contentType: varchar("content_type").notNull(), // message, comment, blog_post
  contentId: varchar("content_id").notNull(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  originalText: text("original_text").notNull(),
  moderatedText: text("moderated_text"),
  action: varchar("action").notNull(), // approved, filtered, rewritten, flagged
  reason: text("reason"), // AI analysis reason
  sentimentScore: integer("sentiment_score"), // -100 to 100
  toxicityLevel: varchar("toxicity_level"), // low, medium, high
  aiProvider: varchar("ai_provider"), // openai, local_llm, etc
  reviewedBy: varchar("reviewed_by").references(() => users.id), // admin review
  createdAt: timestamp("created_at").defaultNow(),
});

// User notifications system
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: varchar("user_id").references(() => users.id).notNull(),
  type: varchar("type").notNull(), // message, comment_reply, blog_approved, etc
  title: varchar("title").notNull(),
  message: text("message").notNull(),
  relatedId: integer("related_id"), // reference to related content
  relatedType: varchar("related_type"), // blog_post, message, comment
  isRead: boolean("is_read").default(false),
  actionUrl: varchar("action_url"), // deep link for notification action
  createdAt: timestamp("created_at").defaultNow(),
});

// Type exports
export type User = typeof users.$inferSelect;
export type UpsertUser = typeof users.$inferInsert;

// Insert schemas with omitted auto-generated fields
export const insertBlogPostSchema = createInsertSchema(blogPosts).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertContactMessageSchema = createInsertSchema(contactMessages).omit({
  id: true,
  createdAt: true,
});

export const insertAnalyticsSchema = createInsertSchema(analytics).omit({
  id: true,
  timestamp: true,
});

export const insertMessageSchema = createInsertSchema(messages).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCommentSchema = createInsertSchema(comments).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertModerationLogSchema = createInsertSchema(moderationLogs).omit({
  id: true,
  createdAt: true,
});

export const insertNotificationSchema = createInsertSchema(notifications).omit({
  id: true,
  createdAt: true,
});

// Type definitions for all tables
export type InsertBlogPost = z.infer<typeof insertBlogPostSchema>;
export type BlogPost = typeof blogPosts.$inferSelect;
export type InsertContactMessage = z.infer<typeof insertContactMessageSchema>;
export type ContactMessage = typeof contactMessages.$inferSelect;
export type InsertAnalytics = z.infer<typeof insertAnalyticsSchema>;
export type Analytics = typeof analytics.$inferSelect;
export type GithubProject = typeof githubProjects.$inferSelect;
export type InsertMessage = z.infer<typeof insertMessageSchema>;
export type Message = typeof messages.$inferSelect;

// Audio play logs schema
export const insertAudioPlayLogSchema = createInsertSchema(audioPlayLogs);
export type InsertAudioPlayLog = z.infer<typeof insertAudioPlayLogSchema>;
export type AudioPlayLog = typeof audioPlayLogs.$inferSelect;

// Audit logs schema  
export const insertAuditLogSchema = createInsertSchema(auditLogs);
export type InsertAuditLog = z.infer<typeof insertAuditLogSchema>;
export type AuditLog = typeof auditLogs.$inferSelect;

// Failed login attempts schema
export const insertFailedLoginAttemptSchema = createInsertSchema(failedLoginAttempts);
export type InsertFailedLoginAttempt = z.infer<typeof insertFailedLoginAttemptSchema>;
export type FailedLoginAttempt = typeof failedLoginAttempts.$inferSelect;

// System health schema
export const insertSystemHealthSchema = createInsertSchema(systemHealth);
export type InsertSystemHealth = z.infer<typeof insertSystemHealthSchema>;
export type SystemHealth = typeof systemHealth.$inferSelect;
export type InsertComment = z.infer<typeof insertCommentSchema>;
export type Comment = typeof comments.$inferSelect;
export type InsertModerationLog = z.infer<typeof insertModerationLogSchema>;
export type ModerationLog = typeof moderationLogs.$inferSelect;
export type InsertNotification = z.infer<typeof insertNotificationSchema>;
export type Notification = typeof notifications.$inferSelect;
